
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery_examples/basic_usage.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_examples_basic_usage.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_examples_basic_usage.py:


Basic usage
===========

This example demonstrates the basic usage of combined TFRs and how to
compute and plot them using the ctfr package.

.. GENERATED FROM PYTHON SOURCE LINES 9-15

.. code-block:: Python


    import ctfr
    import numpy as np
    import matplotlib.pyplot as plt









.. GENERATED FROM PYTHON SOURCE LINES 16-18

--------------


.. GENERATED FROM PYTHON SOURCE LINES 21-24

Loading the audio data
~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 27-36

Our synthetic example consists of :math:`1` s of audio data sampled at
:math:`22050 Hz`. The signal is comprised of two superposed sinusoidal
components with frequencies :math:`f_1 = 440` Hz and :math:`f_2 = 506`
Hz, as well as a pulse component with a short duration around
:math:`t = 0.5` s. We will see how the ctfr package can help us compute
a combined TFR of STFTs with good resolution in both time and frequency
domains, which is not possible with a traditional STFT. Let’s load the
audio data and plot it.


.. GENERATED FROM PYTHON SOURCE LINES 36-43

.. code-block:: Python


    # Load and print the audio signal.
    signal, sr = ctfr.load("audio/synthetic.wav")
    print(f"Sample rate: {sr} Hz")
    plt.plot(signal);





.. image-sg:: /gallery_examples/images/sphx_glr_basic_usage_001.png
   :alt: basic usage
   :srcset: /gallery_examples/images/sphx_glr_basic_usage_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Sample rate: 22050 Hz

    [<matplotlib.lines.Line2D object at 0x7e16e901d5d0>]



.. GENERATED FROM PYTHON SOURCE LINES 44-46

--------------


.. GENERATED FROM PYTHON SOURCE LINES 49-52

Computing STFT spectrograms with different resolutions.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 55-59

Now, let’s compute plot an STFT spectrogram of the audio signal. We will
use a window length of :math:`L = 512` samples (~ :math:`23` ms), a hop
length of :math:`512` samples, and a FFT size of :math:`2048` samples.


.. GENERATED FROM PYTHON SOURCE LINES 59-69

.. code-block:: Python


    # Compute the spectrogram with L = 512.
    spec_512 = ctfr.stft_spec(signal, win_length=512, n_fft=2048, hop_length=256)

    # Plot the spectrogram.
    img = ctfr.specshow(ctfr.power_to_db(spec_512, ref=np.max), sr=sr, hop_length=256, x_axis='time', y_axis='linear', cmap='inferno')
    plt.ylim(0, 1000)
    plt.colorbar(img, format="%+2.0f dB");





.. image-sg:: /gallery_examples/images/sphx_glr_basic_usage_002.png
   :alt: basic usage
   :srcset: /gallery_examples/images/sphx_glr_basic_usage_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7e16e9087ad0>



.. GENERATED FROM PYTHON SOURCE LINES 70-78

We can see that the the pulse component’s onset and offset are well
delineated, but the sinusoidal components are not well resolved in the
frequency domain. This is due to the short window length, which provides
good time resolution but poor frequency resolution.

Now, let’s increase the window length to :math:`L = 1024` samples (~
:math:`46` ms) and plot the STFT spectrogram again.


.. GENERATED FROM PYTHON SOURCE LINES 78-88

.. code-block:: Python


    # Compute the spectrogram with L = 1024.
    spec_1024 = ctfr.stft_spec(signal, win_length=1024, n_fft=2048, hop_length=256)

    # Plot the spectrogram.
    img = ctfr.specshow(ctfr.power_to_db(spec_1024, ref=np.max), sr=sr, hop_length=256, x_axis='time', y_axis='linear', cmap='inferno')
    plt.ylim(0, 1000)
    plt.colorbar(img, format="%+2.0f dB");





.. image-sg:: /gallery_examples/images/sphx_glr_basic_usage_003.png
   :alt: basic usage
   :srcset: /gallery_examples/images/sphx_glr_basic_usage_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7e16e90da150>



.. GENERATED FROM PYTHON SOURCE LINES 89-96

Wee see that our frequency resolution is improved at cost of poorer time
resolution.

Let’s go even further and increase our window length to :math:`L = 2048`
samples (~ :math:`93` ms), compute the corresponding STFT and plot the
resulting spectrogram.


.. GENERATED FROM PYTHON SOURCE LINES 96-106

.. code-block:: Python


    # Compute the spectrogram with L = 1024.
    spec_2048 = ctfr.stft_spec(signal, win_length=2048, n_fft=2048, hop_length=256)

    # Plot the spectrogram.
    img = ctfr.specshow(ctfr.power_to_db(spec_2048, ref=np.max), sr=sr, hop_length=256, x_axis='time', y_axis='linear', cmap='inferno')
    plt.ylim(0, 1000)
    plt.colorbar(img, format="%+2.0f dB");





.. image-sg:: /gallery_examples/images/sphx_glr_basic_usage_004.png
   :alt: basic usage
   :srcset: /gallery_examples/images/sphx_glr_basic_usage_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7e16e8f9a150>



.. GENERATED FROM PYTHON SOURCE LINES 107-111

With this larger window length, our sinusoidal components are now well
resolved in the frequency domain, but the pulse component’s onset and
offset are not well delineated.


.. GENERATED FROM PYTHON SOURCE LINES 114-116

--------------


.. GENERATED FROM PYTHON SOURCE LINES 119-122

Computing a combined TFR
~~~~~~~~~~~~~~~~~~~~~~~~


.. GENERATED FROM PYTHON SOURCE LINES 125-135

In summary, what we have seen is the time-frequency trade-off. Achieving
better frequency resolution (by increasing the window length) comes at
the cost of poorer time resolution, and vice versa. However, we can
circumvent this problem by computing a combined TFR, which is an average
(in a generalized sense, depending on the combination method) of
multiple STFTs computed with different window lengths. This allows us to
achieve good resolution in both time and frequency domains.

Let’s see how we can do this using this package.


.. GENERATED FROM PYTHON SOURCE LINES 138-141

Using ctfr.ctfr_from_specs
^^^^^^^^^^^^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 144-150

Since we have already computed STFTs with different window lengths, we
can use the ``ctfr_from_specs`` function to compute a combined TFR from
these STFT spectrograms. This function requires an iterable of STFT
spectrograms with the same time-frequency alignment. Since we used the
same hop length and FFT size for all STFTs, they are already aligned.


.. GENERATED FROM PYTHON SOURCE LINES 150-156

.. code-block:: Python


    print(spec_512.shape)
    print(spec_1024.shape)
    print(spec_2048.shape)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (1025, 87)
    (1025, 87)
    (1025, 87)




.. GENERATED FROM PYTHON SOURCE LINES 157-160

We also have to provide a combination method. Let’s list all available
methods:


.. GENERATED FROM PYTHON SOURCE LINES 160-164

.. code-block:: Python


    ctfr.list_methods()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Listing installed methods:

    - Binwise Mean -- mean
    - Binwise Median -- median
    - Binwise Minimum -- min
    - Sample Weighted Geometric Mean (SWGM) -- swgm
    - Fast Local Sparsity (FLS) -- fls
    - Lukin-Todd (LT) -- lt
    - Local Sparsity (LS) -- ls




.. GENERATED FROM PYTHON SOURCE LINES 165-169

For this example, we’ll use the Sample-Weighted Geometric Mean (SWGM),
which is a lightweight and effective binwise combination method. Let’s
compute the combined TFR and plot it.


.. GENERATED FROM PYTHON SOURCE LINES 169-179

.. code-block:: Python


    # Compute the combined spectrogram using ctfr.ctfr_from_specs and the SWGM method,
    swgm_spec = ctfr.ctfr_from_specs((spec_512, spec_1024, spec_2048), method='swgm')

    # Plot the combined spectrogram.
    img = ctfr.specshow(ctfr.power_to_db(swgm_spec, ref=np.max), sr=sr, hop_length=256, x_axis='time', y_axis='linear', cmap='inferno')
    plt.ylim(0, 1000)
    plt.colorbar(img, format="%+2.0f dB");





.. image-sg:: /gallery_examples/images/sphx_glr_basic_usage_005.png
   :alt: basic usage
   :srcset: /gallery_examples/images/sphx_glr_basic_usage_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7e16e8be3290>



.. GENERATED FROM PYTHON SOURCE LINES 180-184

As we can see, we have achieved good resolution in both time and
frequency domains, with the sinusoidal components and the pulse
component well resolved.


.. GENERATED FROM PYTHON SOURCE LINES 187-189

--------------


.. GENERATED FROM PYTHON SOURCE LINES 192-195

Using ctfr.ctfr
^^^^^^^^^^^^^^^


.. GENERATED FROM PYTHON SOURCE LINES 198-206

Using ``ctfr_from_specs`` is useful when we already have the STFT
spectrograms to combine, or when we want more control over how to
generate them. When we just want to compute a combined TFR directly from
an audio signal, we can use the ``ctfr`` function, which computes the
STFT spectrograms with different window lengths and then combines them.

Let’s do this for our signal, using the same parameters as before.


.. GENERATED FROM PYTHON SOURCE LINES 206-216

.. code-block:: Python


    # Compute the combined spectrogram using ctfr.ctfr and the SWGM method,
    swgm_spec_2 = ctfr.ctfr(signal, sr = sr, method = "swgm", win_length_list=[512, 1024, 2048], hop_length=256, n_fft=2048)

    # Plot the combined spectrogram.
    img = ctfr.specshow(ctfr.power_to_db(swgm_spec_2, ref=np.max), sr=sr, hop_length=512, x_axis='time', y_axis='linear', cmap='inferno')
    plt.ylim(0, 1000)
    plt.colorbar(img, format="%+2.0f dB");





.. image-sg:: /gallery_examples/images/sphx_glr_basic_usage_006.png
   :alt: basic usage
   :srcset: /gallery_examples/images/sphx_glr_basic_usage_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.colorbar.Colorbar object at 0x7e16e87482d0>



.. GENERATED FROM PYTHON SOURCE LINES 217-221

We can see that the combined spectrogram looks the same as the one we
computed in the previous section. Let’s confirm that they’re indeed the
same:


.. GENERATED FROM PYTHON SOURCE LINES 221-222

.. code-block:: Python


    np.array_equal(swgm_spec, swgm_spec_2)



.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.394 seconds)


.. _sphx_glr_download_gallery_examples_basic_usage.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: basic_usage.ipynb <basic_usage.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: basic_usage.py <basic_usage.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: basic_usage.zip <basic_usage.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
